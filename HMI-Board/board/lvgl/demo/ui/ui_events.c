// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.1
// LVGL version: 8.3.11
// Project name: SquareLine_Project

#include "ui.h"
#include <rtthread.h>
#include "src/uart4.h"
#include "src/can.h"
#include "src/commands_def.h"
#include <stdio.h>
#include <rtdevice.h>
#include <rtdbg.h>
#include <r_gpt.h>
#include "hal_data.h"
#include "src/standby_timer.h"
#include "llm.h"
#include "src/event.h"

#define DBG_TAG "main"
#define DBG_LVL DBG_LOG

struct rt_semaphore read_sem, show_sem;
bool inback_flag = true;
static bool finger_flag = true;
static rt_thread_t read_th, del_th, tim_th = RT_NULL, show_th = RT_NULL;
static lv_obj_t * kb;

static time_t last;
static struct tm nowtime;
static time_t now;
static char timstr[9], datestr[23];
static const char *week_str[] = {"日", "一", "二", "三", "四", "五", "六"};

extern llm_shared_data_t llm_answer;
extern char msg[512];
//extern struct rt_semaphore call_deepseek_sem;
extern lv_font_t restext_font;

extern uint32_t last_touch_time;
void touch_event_handler(lv_event_t * e){
    last_touch_time = lv_tick_get();
    backlight_on();
}

static void tim_thread_entry(rt_thread_t *parameter){
    last = time(RT_NULL);
    static int last_day = -1;

    while (true){
        now = time(RT_NULL);

        if (now != last){
            localtime_r(&now, &nowtime);
            sprintf(timstr, "%02d:%02d:%02d", nowtime.tm_hour, nowtime.tm_min, nowtime.tm_sec);
            lv_label_set_text(ui_time, timstr);
            last = now;
        }
        if (nowtime.tm_mday != last_day) {
            last_day = nowtime.tm_mday;
            sprintf(datestr, "%d年 %d月%d日 星期%s", nowtime.tm_year + 1900, nowtime.tm_mon + 1,
                    nowtime.tm_mday, week_str[nowtime.tm_wday]);
            lv_label_set_text(ui_date, datestr);
        }

        rt_thread_mdelay(10);
    }
}

static void show_thread_entry(rt_thread_t *parameter){
    static char safe_buf[PKG_WEB_SORKET_BUFSZ];
    while (true){
        rt_sem_take(&show_sem, RT_WAITING_FOREVER);
        /*
        _ui_screen_change(&ui_emotion, LV_SCR_LOAD_ANIM_FADE_ON, 0, 0, &ui_emotion_screen_init);

        lv_obj_add_flag(ui_sad, LV_OBJ_FLAG_HIDDEN);
        lv_obj_add_flag(ui_question, LV_OBJ_FLAG_HIDDEN);
        lv_obj_clear_flag(ui_smile, LV_OBJ_FLAG_HIDDEN);
        */

        /*
        rt_mutex_take(&llm_answer.lock, RT_WAITING_FOREVER);
        if (llm_answer.response_ready) {
            rt_strncpy(safe_buf, llm_answer.response, sizeof(safe_buf) - 1);
            lv_async_call(show_response_segmented, safe_buf);
            //lv_label_set_text(ui_responsetext, llm_answer.response);
            llm_answer.response_ready = RT_FALSE;
        }
        rt_mutex_release(&llm_answer.lock);
        */

        if (!strcmp(command, SHOW_SMILE)) {
            lv_obj_add_flag(ui_sad, LV_OBJ_FLAG_HIDDEN);
            lv_obj_add_flag(ui_question, LV_OBJ_FLAG_HIDDEN);
            lv_obj_clear_flag(ui_smile, LV_OBJ_FLAG_HIDDEN);
        }
        if (!strcmp(command, SHOW_SAD)) {
            lv_obj_add_flag(ui_smile, LV_OBJ_FLAG_HIDDEN);
            lv_obj_add_flag(ui_question, LV_OBJ_FLAG_HIDDEN);
            lv_obj_clear_flag(ui_sad, LV_OBJ_FLAG_HIDDEN);
        }
        if (!strcmp(command, SHOW_QUESTION)) {
            lv_obj_add_flag(ui_sad, LV_OBJ_FLAG_HIDDEN);
            lv_obj_add_flag(ui_smile, LV_OBJ_FLAG_HIDDEN);
            lv_obj_clear_flag(ui_question, LV_OBJ_FLAG_HIDDEN);
        }
        if (!strcmp(command, SHOW_EMO_END)) {
            _ui_screen_change(&ui_mainscreen, LV_SCR_LOAD_ANIM_FADE_ON, 0, 0, &ui_mainscreen_screen_init);
        }

    }
}

void update_time(lv_event_t * e)
{
    // Your code here

    lv_obj_set_style_text_font(ui_responsetext, &restext_font, LV_PART_MAIN);
    if (tim_th == RT_NULL){
        tim_th = rt_thread_create("tim_recv", tim_thread_entry, NULL, 1024, 24, 5);
        rt_thread_startup(tim_th);
    }

    if (show_th == RT_NULL){
        rt_sem_init(&show_sem, "show_sem", 0, RT_IPC_FLAG_FIFO);
        show_th = rt_thread_create("show_recv", show_thread_entry, NULL, 1024, 25, 5);
        rt_thread_startup(show_th);
    }

}

void disease_anl(lv_event_t * e)
{
    // Your code here
    strcpy(msg, "根据用药分析我的病情：");
    rt_event_send(speak_event, EVENT_GET_INFO);
    //rt_sem_release(&call_deepseek_sem);
    can_send(MEDICINE_GET_INFO, 1);
}

void del_thread_entry(rt_thread_t *parameter){
    rt_sem_detach(&read_sem);
    rt_thread_delete(read_th);
}

void read_thread_entry(rt_thread_t *parameter){
    while (true){
        if (inback_flag) return;

        rt_sem_take(&read_sem, RT_WAITING_FOREVER);

        if (!strcmp(command, MEDICINE_INFOIN_SUCCESS)){
            command[0] = '\0';
            lv_obj_add_flag(ui_scanhint, LV_OBJ_FLAG_HIDDEN);
            lv_obj_clear_flag(ui_Panel1, LV_OBJ_FLAG_HIDDEN);
        }
        else if (!strcmp(command, IDENTITY_SUCCESS)){
            command[0] = '\0';
            lv_obj_add_flag(ui_fingertext, LV_OBJ_FLAG_HIDDEN);
            lv_obj_clear_flag(ui_time, LV_OBJ_FLAG_HIDDEN);

            if (finger_flag){
                lv_label_set_text(ui_loginouttext, "解除绑定");
                finger_flag = !finger_flag;
            }
            else{
                lv_label_set_text(ui_loginouttext, "身份绑定");
                finger_flag = !finger_flag;
            }

            inback_flag = true;

            //lv_obj_clear_flag(ui_loginoutbutton, LV_OBJ_FLAG_HIDDEN);
            //lv_obj_clear_flag(ui_medicineinbutton, LV_OBJ_FLAG_HIDDEN);
            //lv_obj_clear_flag(ui_medicineoutbutton, LV_OBJ_FLAG_HIDDEN);

            del_th = rt_thread_create("del_recv", del_thread_entry, NULL, 1024, 23, 5);
            rt_thread_startup(del_th);
            return;
        }
    }
}

void read_finger(lv_event_t * e)
{
	// Your code here
    if (finger_flag){
        //rt_device_write(u4_dev, 0, IDENTITY_BIND, 1);
        can_send(IDENTITY_BIND, 1);
    }
    else{
        //rt_device_write(u4_dev, 0, IDENTITY_UNBIND, 1);
        can_send(IDENTITY_UNBIND, 1);
    }

    //lv_obj_add_flag(ui_loginoutbutton, LV_OBJ_FLAG_HIDDEN);
    //lv_obj_add_flag(ui_medicineinbutton, LV_OBJ_FLAG_HIDDEN);
    //lv_obj_add_flag(ui_medicineoutbutton, LV_OBJ_FLAG_HIDDEN);

    inback_flag = false;
    rt_sem_init(&read_sem, "read_sem", 0, RT_IPC_FLAG_FIFO);
    read_th = rt_thread_create("read_recv", read_thread_entry, NULL, 1024, 22, 5);
    rt_thread_startup(read_th);
}

void read_bar(lv_event_t * e)
{
	// Your code here
    //rt_device_write(u4_dev, 0, MEDICINE_IN_BEGIN, 1);
    can_send(MEDICINE_IN_BEGIN, 1);

    inback_flag = false;
    rt_sem_init(&read_sem, "read_sem", 0, RT_IPC_FLAG_FIFO);
    read_th = rt_thread_create("read_recv", read_thread_entry, NULL, 1024, 21, 5);
    rt_thread_startup(read_th);
}

void m_inback(lv_event_t * e)
{
    // Your code here
    inback_flag = true;

    //rt_device_write(u4_dev, 0, MEDICINE_IN_END, 1);
    can_send(MEDICINE_IN_END, 1);

    rt_sem_detach(&read_sem);
    rt_thread_delete(read_th);
}

void msg_send(lv_event_t * e)
{
	// Your code here
    kb = lv_event_get_target(e);  // 获取触发事件的对象
    const char * txt = lv_btnmatrix_get_btn_text(kb, lv_btnmatrix_get_selected_btn(kb));// 获取按键文本

    if (txt == LV_SYMBOL_OK){
        lv_obj_add_flag(ui_Panel1, LV_OBJ_FLAG_HIDDEN);
        lv_obj_clear_flag(ui_scanhint, LV_OBJ_FLAG_HIDDEN);

        static char msg[20] = {};
        const char * times = lv_textarea_get_text(ui_times);
        const char * amount = lv_textarea_get_text(ui_amount);
        sprintf(msg, "%s,%s", times, amount);

        //rt_device_write(u4_dev, 0, msg, rt_strlen(msg));
        can_send(msg, rt_strlen(msg));

        lv_textarea_set_text(ui_times, "");
        lv_textarea_set_text(ui_amount, "");
    }
}

void medicine_out(lv_event_t * e)
{
    // Your code here
    //rt_device_write(u4_dev, 0, MEDICINE_OUT_BEGIN, 1);
    can_send(MEDICINE_OUT_BEGIN, 1);
}

void del_medicine(lv_event_t * e)
{
	// Your code here
    kb = lv_event_get_target(e);

    if (kb == ui_out1) can_send(MEDICINE_OUT_1, 1);
    else if (kb == ui_out2) can_send(MEDICINE_OUT_2, 1);
    else if (kb == ui_out3) can_send(MEDICINE_OUT_3, 1);
    else if (kb == ui_out4) can_send(MEDICINE_OUT_4, 1);
    else if (kb == ui_out5) can_send(MEDICINE_OUT_5, 1);
}

void m_outback(lv_event_t * e)
{
    // Your code here
    //rt_device_write(u4_dev, 0, MEDICINE_OUT_END, 1);
    can_send(MEDICINE_OUT_END, 1);
}
